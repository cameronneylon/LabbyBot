#!python## Copyright 2009 Jonathon Hunt, Dan Hagon, Cameron Neylon## Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.#from google.appengine.ext import webappfrom google.appengine.ext.webapp import utilimport feedparserfrom waveapi import eventsfrom waveapi import modelfrom waveapi import robotfrom waveapi import documentfrom waveapi import simplejson as jsonimport loggingdef parsefeed(feed):    """Take a URI and parse the feed to generate menu list    Uses feedparser.parse to get a feed and returns a list of items, currently    as a simple list. It might be better to do this as a dictionary. It attempts    to get a date from either entry.updated (which is usually filled from an    RSS feed) or entry.published (which is usually filled from an ATOM feed).    """    #TODO: Need to properly check whether feed starts http:// if not then include    #if feed[0:7] != 'http://':    #    feed = 'http://' + feed    parsedfeed = feedparser.parse(feed) #parse the feed using feedparser library    # logging.debug('Parsing feed:'+ feed + str(parsedfeed))    itemslist = [] #list for holding titles, links etc.    # Iterate over the list of entries and populate a list containing titles, links etc.    for entry in parsedfeed.entries: #populate the list with items         title = entry.get('title', 'No title')        link = entry.get('link', 'No link')        updated = entry.get('updated', 'No date available') # Try to get date from 'updated'        if updated == 'No date available':                updated = entry.get('published', 'No date available') # if not try to get from 'published'        if 'enclosures' in entry:            enclosure = entry.enclosures[0].get('href', 'No enclosure link available')            enclosuretype = entry.enclosures[0].get('type', 'No enclosure type available')            # logging.debug('Enclosure link:' + enclosure + ' Enclosure type:' + enclosuretype)                else:            enclosure = 'none' # there are no enclosures        # logging.debug('Title:' + title + ' Link:' + link + ' Enclosure:' + enclosure)        itemslist.append([title, link, updated, enclosure]) # returned list of attributes. Should this be a dictionary?    return itemslist def insertItem(properties, context, inputoutput = 'input', attemptdata = False):    """User has chosen an object to insert."""    logging.debug('insertItem()')    # Get title, URL, and enclosure URLs from the gadget state    gadgetblip = context.GetBlipById(properties['blipId'])    logging.debug(properties['blipId'])    sourceGadget = gadgetblip.GetGadgetByUrl(             'http://labnotebot.appspot.com/gadgets/feed-item-select-dropdown.xml')    sourceUrl = sourceGadget.get('selectedentry_url')    title = sourceGadget.get('selectedentry_title')    enclosureUrl = sourceGadget.get('selectedentry_img')    logging.debug('Inserting ' + sourceUrl)    logging.debug('Img source ' + enclosureUrl)    # Actually insert the object: Want to change this to insert into root blip of wavelet    # It is apparently not possible to do this except by a horrible hack as the context    # does not include the root blip of the root wavelet.    # rootWavelet = context.GetRootWavelet()    # rootBlipId = rootWavelet.GetRootBlipId()    # logging.debug(rootBlipId)    # logging.debug(str(context))    # rootBlip = GetBlipById(rootBlipId)    # doc = rootBlip.GetDocument()    # doc.AppendText(title)        # insertblipid = context.GetRootWavelet().GetRootBlipId()    insertblip = context.GetBlipById(properties['blipId'])    insertblip.GetDocument().AppendText(title + ' ')    r = document.Range()    r.start = insertblip.GetDocument().GetText().find(title)    r.end = r.start + len(title)    insertblip.GetDocument().SetAnnotation(r, 'link/manual', sourceUrl) #add link    insertblip.GetDocument().SetAnnotation(r, 'insertedbyRobot', 'labnotebot')    insertblip.GetDocument().SetAnnotation(r, 'namespace/labnotebot', inputoutput)    if attemptdata == 'true':        if enclosureUrl.endswith('jpg'):            image = document.Image(enclosureUrl)            insertblip.GetDocument().AppendElement(image)        else:            pass        def insertInput(properties, context):    """Called when the Insert as an input button is pressed"""    logging.debug('insertInput()')    inputoutput = 'input'    blip = context.GetBlipById(properties['blipId'])    e = filter(lambda e: hasattr(e, 'name') and e.name == 'attemptData', blip.GetElements().values())    assert(len(e) == 1) # There should only be one matching element    attemptdata = e[0].value    logging.debug(attemptdata)    insertItem(properties, context, inputoutput, attemptdata)def insertProduct(properties, context):    """Called when the Insert as an output button is pressed"""    logging.debug('insertOutput()')    inputoutput = 'output'    blip = context.GetBlipById(properties['blipId'])    e = filter(lambda e: hasattr(e, 'name') and e.name == 'attemptData', blip.GetElements().values())    assert(len(e) == 1) # There should only be one matching element    attemptdata = e[0].value    logging.debug(attemptdata)    insertItem(properties, context, inputoutput, attemptdata)def addForm(wavelet):    """Add form elements as the GUI (for choosing the RSS feed and inserting elements).    """    formblip = wavelet.CreateBlip()    formdoc = formblip.GetDocument()    formdoc.AppendElement(document.FormElement(                          'INPUT', 'feedTextbox', 'http://cameronneylon.net/feed'))    formdoc.AppendElement(document.FormElement(                          'BUTTON', 'insertFeed', 'Insert feed'))def insertFeed(properties, context):    """The user wants a feed added."""    logging.debug('Add feed list elements')    blip = context.GetBlipById(properties['blipId'])    elements = blip.GetElements()    e = filter(lambda e: hasattr(e, 'name') and e.name == 'feedTextbox', blip.GetElements().values())    assert(len(e) == 1) # There should only be one matching element    feedurl= e[0].value    logging.debug('Feed url=' + feedurl)    # Now fetch the form elements and populate list    items = parsefeed(feedurl)    doc = blip.GetDocument()    # Only pass the items needed to populate the list    # Current each entry is a tuple of title, url, enclosure_url    items = map(lambda i: (i[0], i[1], i[3]), items)    logging.debug(items)    # Check whether gadget already exists and if so simply update list    menuGadget = blip.GetGadgetByUrl(             'http://labnotebot.appspot.com/gadgets/feed-item-select-dropdown.xml')    logging.debug(str(menuGadget))    if menuGadget:        logging.debug('Gadget exists!')        blip.GetDocument().GadgetSubmitDelta(menuGadget,                     {'list' :''})        blip.GetDocument().GadgetSubmitDelta(menuGadget,                     {'list' :json.dumps(items, sort_keys=False)})    else:        doc.AppendText('\n\n')        doc.AppendElement(document.Gadget(                    'http://labnotebot.appspot.com/gadgets/feed-item-select-dropdown.xml',                    {'list' : json.dumps(items, sort_keys=False)}))        doc.AppendElement(document.FormElement('BUTTON', 'insertInput', 'Insert as input'))        doc.AppendElement(document.FormElement('BUTTON', 'insertProduct', 'Insert as product'))        doc.AppendElement(document.FormElement('CHECK', 'attemptData', 'false'))        doc.AppendText('Attempt to insert data?\n')def OnFormClicked(properties, context):    """Handle all form events."""    logging.debug('OnFormClicked(): Button clicked was ' + properties['button'])    # Call the corresponding handler - will give an exception if no handler exists    {'insertFeed' : insertFeed,     'insertInput' : insertInput,     'insertProduct' : insertProduct}[properties['button']](properties, context)def OnBlipSubmitted(properties, context):    """Parser to generate a structured list of inputs/outputs when triggered"""    logging.debug('OnBlipSubmitted()')    blip = context.GetBlipById(properties['blipId'])    text = blip.GetDocument().GetText()    if text.find('Structured Data') != -1:    # if the trigger string is present then...        inputs = []        outputs = []        linklist = []        annotationlist = []        inputstring = ''        outputstring = ''        # iterate over each annotation in the blip        for eachannotation in blip.GetAnnotations():            # set up a dictionary with name, range, and value of each annotation            annotationlist.append({'name'  : eachannotation.name,                                   'range' : eachannotation.range,                                   'value' : eachannotation.value})            # set up a dictionary with text, range, and blank url for each annotation            # which matches 'namespace/labnotebot'            if eachannotation.name == 'namespace/labnotebot':                # set up dictionary of inputs                if eachannotation.value == 'input':                    inputs.append({'text'  : text[eachannotation.range.start:                                                   eachannotation.range.end],                                   'range' : eachannotation.range,                                   'url'   : ''})                                # set up dictionary of outputs                elif eachannotation.value == 'output':                    outputs.append({'text'  : text[eachannotation.range.start:                                                    eachannotation.range.end],                                    'range' : eachannotation.range,                                     'url'   : '' })                else:                    pass            # setup dictionary of links            elif eachannotation.name == 'link/manual':                linklist.append({'url'  : eachannotation.value,                                  'range': eachannotation.range})            else:                pass        # for each annotated input find the matching link and place into dictionary        for input in inputs:            for links in linklist:                if (input['range'].start == links['range'].start                        ) and (input['range'].end == links['range'].end):                   input.update({'url' : links['url']})                   # setup string for insertion                   inputstring = inputstring + (input['text'] + ': '                                                     + input['url'] + '\n')        # for each annotated output find the matching link and place into dictionary        for output in outputs:            for links in linklist:                if (output['range'].start == links['range'].start                        ) and (output['range'].end == links['range'].end):                   output.update({'url' : links['url']})                   # setup string for insertion                   outputstring = outputstring + (output['text'] + ': '                                                     + output['url'] +'\n')        # setup string to identify wave, wavelet, blip        blipstring = ('Wave: ' + blip.GetWaveId() + '\nWavelet: ' +                            blip.GetWaveletId() + '\nBlip: ' + blip.GetId() + '\n')        # insert all the strings that describe local doc, inputs and outputs        blip.GetDocument().AppendText('\nThis document:\n' + blipstring)        blip.GetDocument().AppendText('\nInputs:\n' + inputstring)        blip.GetDocument().AppendText('\nOutputs:\n' + outputstring)        rdfheader = """\n\n\n\n\n<rdf:RDF   xlmns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"   xmlns:dc="http://purl.org/dc/elements/1.1/"   xmlns:mylabns="http://example.org/mylabnamespace"\n>"""        rdfcreator = ''        rdfinputs = ''        rdfoutputs = ''        rdfwaveid = """\n\n    <item rdf:about="http://""" + blip.GetWaveId() + ':' + blip.GetId() + '">' + "\n        <mylabns:class>process</mylabns:class>"        for author in blip.GetContributors():            rdfcreator = rdfcreator + "\n        <dc:creator>" + author + "</dc:creator>"        for input in inputs:            rdfinputs = rdfinputs + "\n        <mylabns:hasinput>" + input['url'] + "</mylabns:hasinput>"        for output in outputs:            rdfoutputs = rdfoutputs + "\n        <mylabns:hasoutput>" + output['url'] + "</mylabns:hasoutput>"        rdffooter = "\n    </item>\n</rdf:RDF>"        blip.GetDocument().AppendText(rdfheader + rdfwaveid + rdfcreator + rdfinputs + rdfoutputs + rdffooter)        def OnRobotAdded(properties, context):    """Invoked when the robot has been added.    In this case we need to add the form elements for selecting a feed"""    logging.info('OnRobotAdded()')    root_wavelet = context.GetRootWavelet()    root_wavelet.CreateBlip().GetDocument().SetText("Hello, I'm LabNoteBot. I parse RSS/Atom feeds to populate a dropdown menu and help you connect your research objects up together. This is Version 0.4 of LabNoteBot")    addForm(root_wavelet)def main():    labnotebot = robot.Robot('labnotebot',                          image_url='http://www.chemspider.com/ImagesHandler.ashx?id=236',                          version = '2',                          profile_url='http://labnotebot.appspot.com')    labnotebot.RegisterHandler(events.BLIP_SUBMITTED, OnBlipSubmitted)    labnotebot.RegisterHandler(events.WAVELET_SELF_ADDED, OnRobotAdded)    labnotebot.RegisterHandler(events.FORM_BUTTON_CLICKED, OnFormClicked)    labnotebot.Run(debug=True)if __name__ == '__main__':    main()