#!python## Copyright 2009 Jonathon Hunt, Dan Hagon, Cameron Neylon## Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.##import loggingfrom waveapi import eventsfrom waveapi import opsfrom waveapi import elementfrom waveapi import robotfrom waveapi import appengine_robot_runnerfrom waveapi import simplejson as jsonimport feedparserimport loggingdef parsefeed(feed):    """Take a URI and parse the feed to generate menu list    Uses feedparser.parse to get a feed and returns a list of items, currently    as a simple list. It might be better to do this as a dictionary. It attempts    to get a date from either entry.updated (which is usually filled from an    RSS feed) or entry.published (which is usually filled from an ATOM feed).    """    #TODO: Need to properly check whether feed starts http:// if not then include    #if feed[0:7] != 'http://':    #    feed = 'http://' + feed    parsedfeed = feedparser.parse(feed) #parse the feed using feedparser library    # logging.debug('Parsing feed:'+ feed + str(parsedfeed))    itemslist = [] #list for holding titles, links etc.    # Iterate over the list of entries and populate a list containing titles, links etc.    for entry in parsedfeed.entries: #populate the list with items         title = entry.get('title', 'No title')        link = entry.get('link', 'No link')        updated = entry.get('updated', 'No date available') # Try to get date from 'updated'        if updated == 'No date available':                updated = entry.get('published', 'No date available') # if not try to get from 'published'        if 'enclosures' in entry:            enclosure = entry.enclosures[0].get('href', 'No enclosure link available')            enclosuretype = entry.enclosures[0].get('type', 'No enclosure type available')            # logging.debug('Enclosure link:' + enclosure + ' Enclosure type:' + enclosuretype)                else:            enclosure = 'none' # there are no enclosures        # logging.debug('Title:' + title + ' Link:' + link + ' Enclosure:' + enclosure)        itemslist.append([title, link, updated, enclosure]) # returned list of attributes. Should this be a dictionary?    return itemslist def insertItem(event, wavelet, inputoutput = 'input', attemptdata = False):    """User has chosen an object to insert."""    logging.debug('insertItem()')    # Get title, URL, and enclosure URLs from the gadget state    gadgetblip = event.blip    sourceGadget = gadgetblip.first(element.Gadget,             url ='http://labnotebot.appspot.com/gadgets/feed-item-select-dropdown.xml')    sourceUrl = sourceGadget.get('selectedentry_url', None)    title = sourceGadget.get('selectedentry_title', None)    enclosureUrl = sourceGadget.get('selectedentry_img', None)    logging.debug('Inserting ' + sourceUrl)    logging.debug('Img source ' + enclosureUrl)    # Actually insert the object: currently just appends to root blip end    rootblip = wavelet.root_blip    rootblip.append(title + ' ')    rootblip.all(title).annotate('link/manual', value = sourceUrl)    rootblip.all(title).annotate('labnotebot.appspot.com/role', value = inputoutput)    if attemptdata == 'true':        if enclosureUrl.endswith('jpg'):            image = element.Image(enclosureUrl, width = 250, height = 250)            rootblip.append(image)        else:            pass        def insertInput(event, wavelet):    """Called when the Insert as an input button is pressed"""    logging.debug('insertInput()')    inputoutput = 'input'    blip = event.blip    attemptDataCheckbox = blip.first(element.Check, name = 'attemptDataCheckbox')    attemptdata = attemptDataCheckbox.get('value', 'false')    logging.debug(attemptdata)    insertItem(event, wavelet, inputoutput, attemptdata)def insertProduct(event, wavelet):    """Called when the Insert as an output button is pressed"""    logging.debug('insertInput()')    inputoutput = 'output'    blip = event.blip    attemptDataCheckbox = blip.first(element.Check, name = 'attemptDataCheckbox')    attemptdata = attemptDataCheckbox.get('value', 'false')    logging.debug(attemptdata)    insertItem(event, wavelet, inputoutput, attemptdata)def addForm(event, wavelet):    """Add form elements as the GUI (for choosing the RSS feed and inserting elements).    """    formblip = wavelet.reply()    textbox = element.TextArea('feedTextbox', 'http://cameronneylon.net/feed')    button = element.Button('insertFeed', 'Add RSS feed to menu')    formblip.append(textbox)    formblip.append(button)def insertFeed(event, wavelet):    """The user wants a feed added."""    logging.debug('Add feed list elements')    blip = event.blip    # Get the textbox and obtain its current value TODO figure out how to check only one    feedTextbox = blip.first(element.TextArea, name = 'feedTextbox')    feedurl=feedTextbox.get('value', None)    logging.debug('Feed url=' + feedurl)    # Now fetch the feed items and populate list for the menu    items = parsefeed(feedurl)    # Only pass the items needed to populate the list    # Current each entry is a tuple of title, url, enclosure_url    items = map(lambda i: (i[0], i[1], i[3]), items)    logging.debug(items)    # Check for gadgets matching the URL (should be none or only one!)CHec    menuGadget = blip.first(element.Gadget, url=             'http://labnotebot.appspot.com/gadgets/feed-item-select-dropdown.xml')    if menuGadget:        logging.debug('Gadget already exists!')        menuGadget.update_element({'list' :json.dumps(items, sort_keys=False)})    else:        # Setup the menu gadget        menuGadget = element.Gadget(                    'http://labnotebot.appspot.com/gadgets/feed-item-select-dropdown.xml',                    {'list' : json.dumps(items, sort_keys=False)})         # Setup the buttons and checkbox        inputButton = element.Button('insertInput', 'Insert as input')        productButton = element.Button('insertProduct', 'Insert as product')        attemptDataCheckbox = element.Check('attemptDataCheckbox', 'false')        # Append the menu and buttons &c        blip.append('\n\n')        blip.append(menuGadget)        blip.append(inputButton)        blip.append(productButton)        blip.append(attemptDataCheckbox)        blip.append('Attempt to insert data?\n')def OnFormClicked(event, wavelet):    """Handle all form events."""    logging.debug('OnFormClicked(): Button clicked was ' + event.properties['buttonName'])    # Call the corresponding handler - will give an exception if no handler exists    {'insertFeed'    : insertFeed,     'insertInput'   : insertInput,     'insertProduct' : insertProduct}[event.properties['buttonName']](event, wavelet)def OnBlipSubmitted(event, wavelet):    """Parser to generate a structured list of inputs/outputs when triggered"""    logging.debug('OnBlipSubmitted()')    blip = event.blip    text = blip.text    if text.find('Structured Data') != -1:    # if the trigger string is present then...        inputs = []        outputs = []        linklist = []        annotationlist = []        inputstring = ''        outputstring = ''        # iterate over each annotation in the blip        for eachannotation in blip.annotations:            # set up a dictionary with name, range, and value of each annotation            annotationlist.append({'name'  : eachannotation.name,                                   'start' : eachannotation.start,                                    'end'   : eachannotation.end,                                   'value' : eachannotation.value})            # set up a dictionary with text, range, and blank url for each annotation            # which matches 'namespace/labnotebot'            if eachannotation.name == 'labnotebot.appspot.com/role':                # set up dictionary of inputs                if eachannotation.value == 'input':                    inputs.append({'text'  : text[eachannotation.start:                                                   eachannotation.end],                                   'start' : eachannotation.start,                                   'end'   : eachannotation.end,                                   'url'   : ''})                                # set up dictionary of outputs                elif eachannotation.value == 'output':                    outputs.append({'text'  : text[eachannotation.start:                                                    eachannotation.end],                                    'start' : eachannotation.start,                                    'end'   : eachannotation.end,                                    'url'   : '' })                else:                    pass            # setup dictionary of links            elif eachannotation.name == 'link/manual':                linklist.append({'url'   : eachannotation.value,                                  'start' : eachannotation.start,                                 'end'   : eachannotation.end})            else:                pass        logging.debug(inputs)        logging.debug(outputs)        logging.debug(linklist)        logging.debug(str(blip.annotations))        # for each annotated input find the matching link and place into dictionary        for input in inputs:            for links in linklist:                if (input['start'] == links['start']                        ) and (input['end'] == links['end']):                   input.update({'url' : links['url']})                   # setup string for insertion                   inputstring = inputstring + (input['text'] + ': '                                                     + input['url'] + '\n')        # for each annotated output find the matching link and place into dictionary        for output in outputs:            for links in linklist:                if (output['start'] == links['start']                        ) and (output['end'] == links['end']):                   output.update({'url' : links['url']})                   # setup string for insertion                   outputstring = outputstring + (output['text'] + ': '                                                     + output['url'] +'\n')        # setup string to identify wave, wavelet, blip        blipstring = ('Wave: ' + blip.wave_id + '\nWavelet: ' +                            blip.wavelet_id + '\nBlip: ' + blip.blip_id + '\n')        # insert all the strings that describe local doc, inputs and outputs        rdfblip = wavelet.reply()        rdfblip.append('\nThis document:\n' + blipstring)        rdfblip.append('\nInputs:\n' + inputstring)        rdfblip.append('\nOutputs:\n' + outputstring)        rdfheader = """\n\n\n\n\n<rdf:RDF   xlmns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"   xmlns:dc="http://purl.org/dc/elements/1.1/"   xmlns:mylabns="http://example.org/mylabnamespace"\n>"""        rdfcreator = ''        rdfinputs = ''        rdfoutputs = ''        rdfwaveid = """\n\n    <item rdf:about="http://""" + blip.wave_id + ':' + blip.blip_id + '">' + "\n        <mylabns:class>process</mylabns:class>"        for author in blip.contributors:            rdfcreator = rdfcreator + "\n        <dc:creator>" + author + "</dc:creator>"        for input in inputs:            rdfinputs = rdfinputs + "\n        <mylabns:hasinput>" + input['url'] + "</mylabns:hasinput>"        for output in outputs:            rdfoutputs = rdfoutputs + "\n        <mylabns:hasoutput>" + output['url'] + "</mylabns:hasoutput>"        rdffooter = "\n    </item>\n</rdf:RDF>"        rdfblip.append(rdfheader + rdfwaveid + rdfcreator + rdfinputs + rdfoutputs + rdffooter)def OnRobotAdded(event, wavelet):    """Invoked when the robot has been added.    In this case we need to add the form elements for selecting a feed"""    logging.info('OnRobotAdded()')    wavelet.reply("Hello, I'm LabNoteBot. I parse RSS/Atom feeds to populate a dropdown menu and help you connect your research objects up together. This is Version 0.4 of LabNoteBot")    addForm(event, wavelet)def main():    labnotebot = robot.Robot('labnotebot',                 image_url='http://www.chemspider.com/ImagesHandler.ashx?id=236',                 profile_url='http://labnotebot.appspot.com')    labnotebot.register_handler(events.BlipSubmitted, OnBlipSubmitted)    labnotebot.register_handler(events.WaveletSelfAdded, OnRobotAdded)    labnotebot.register_handler(events.FormButtonClicked, OnFormClicked)    appengine_robot_runner.run(labnotebot, debug=True)if __name__ == '__main__':    main()